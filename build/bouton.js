/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib sync recursive":
/*!*******************!*\
  !*** ./lib/ sync ***!
  \*******************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./lib sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://bouton/./lib/_sync?");

/***/ }),

/***/ "./lib/Node.js":
/*!*********************!*\
  !*** ./lib/Node.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar uuid = __webpack_require__(/*! uuid */ \"./node_modules/uuid/index.js\");\nvar Node = /*#__PURE__*/function () {\n  function Node(options, eventemitter) {\n    _classCallCheck(this, Node);\n    this.id = uuid.v1();\n    this.options = options;\n    this.ee = eventemitter ? eventemitter : new EventEmitter();\n    this.observers = [];\n    this.upstreams = {};\n    this.downstreams = {};\n    this.meta = {};\n  }\n  _createClass(Node, [{\n    key: \"push\",\n    value: function push(signal) {\n      var _this = this;\n      var interruptible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (interruptible === false || !this.isInterruptibleSignal(signal)) {\n        this.onReceive(signal);\n        return this;\n      }\n      setImmediate(function () {\n        _this.onReceive(signal);\n      });\n      return this;\n    }\n  }, {\n    key: \"onReceive\",\n    value: function onReceive(signal) {\n      this.invokeObservers(\"onReceive\", signal);\n      if (this.isErrorSignal(signal)) {\n        this.onError(signal);\n        this.request();\n      } else if (this.isEndSignal(signal)) {\n        try {\n          this.onEnd(signal);\n        } catch (error) {\n          this.throwError(error, signal);\n        }\n      } else {\n        try {\n          this.onSignal(signal);\n        } catch (error) {\n          this.throwError(error, signal);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"onSignal\",\n    value: function onSignal(signal) {\n      this.send(signal);\n      return this;\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      this.send(error);\n      return this;\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(signal) {\n      this.send(signal);\n      return this;\n    }\n  }, {\n    key: \"send\",\n    value: function send(signal) {\n      var _this2 = this;\n      var interruptible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.invokeObservers(\"send\", signal);\n      if (interruptible === false || !this.isInterruptibleSignal(signal)) {\n        for (var id in this.downstreams) {\n          this.downstreams[id].onReceive(signal);\n        }\n        return this;\n      }\n      setImmediate(function () {\n        _this2.ee.emit(\"outgoing-\" + _this2.id, signal);\n      });\n      return this;\n    }\n  }, {\n    key: \"observe\",\n    value: function observe(observer) {\n      this.observers.push(observer);\n      return this;\n    }\n  }, {\n    key: \"to\",\n    value: function to(downstream) {\n      var _this3 = this;\n      this.invokeObservers(\"to\", downstream);\n      this.downstreams[downstream.id] = downstream;\n      this.ee.on(\"outgoing-\" + this.id, function (signal) {\n        downstream.push(signal);\n      });\n      // for pull model\n      downstream.ee.on(\"request-\" + downstream.id, function (cmd) {\n        _this3.pull(cmd);\n      });\n      downstream.from(this);\n      return downstream;\n    }\n  }, {\n    key: \"pull\",\n    value: function pull(cmd) {\n      var _this4 = this;\n      setImmediate(function () {\n        _this4.onRequest(cmd);\n      });\n      return this;\n    }\n  }, {\n    key: \"onRequest\",\n    value: function onRequest(cmd) {\n      this.invokeObservers(\"onRequest\", cmd);\n      this.request(cmd);\n      return this;\n    }\n  }, {\n    key: \"request\",\n    value: function request(cmd) {\n      var _this5 = this;\n      this.invokeObservers(\"request\", cmd);\n      setImmediate(function () {\n        _this5.ee.emit(\"request-\" + _this5.id, cmd);\n      });\n      return this;\n    }\n  }, {\n    key: \"from\",\n    value: function from(upstream) {\n      this.upstreams[upstream.id] = upstream;\n      this.invokeObservers(\"from\", upstream);\n      return this;\n    }\n  }, {\n    key: \"isInterruptibleSignal\",\n    value: function isInterruptibleSignal(signal) {\n      return true;\n    }\n  }, {\n    key: \"isErrorSignal\",\n    value: function isErrorSignal(signal) {\n      return signal instanceof Error;\n    }\n  }, {\n    key: \"isEndSignal\",\n    value: function isEndSignal(signal) {\n      //$FlowIgnore\n      return signal === Node.END;\n    }\n  }, {\n    key: \"throwError\",\n    value: function throwError(error, signal) {\n      //$FlowIgnore\n      error.signal = signal;\n      return this.send(error);\n    }\n  }, {\n    key: \"invokeObservers\",\n    value: function invokeObservers(when) {\n      var _this6 = this;\n      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n      data.unshift(when);\n      data.unshift(this);\n      try {\n        // run globally registered observers, first\n        for (var name in Node.globalObservers) {\n          Node.globalObservers[name].apply(this, data);\n        }\n        ;\n        this.observers.forEach(function (fn) {\n          fn.apply(_this6, data);\n        });\n      } catch (err) {\n        console.error(err.message);\n      }\n    }\n  }]);\n  return Node;\n}(); //$FlowIgnore\nNode.END = \"__SIGNAL_END__\";\nmodule.exports = Node;\n\n//# sourceURL=webpack://bouton/./lib/Node.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar Node = __webpack_require__(/*! ./Node */ \"./lib/Node.js\");\nfunction shadowCopy(src, target) {\n  for (var k in src) {\n    if (src.hasOwnProperty(k)) {\n      target[k] = src[k];\n    }\n  }\n}\nfunction newInstance() {\n  var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var m = {};\n  m._meta = meta;\n  m._indexers = new Map();\n  m.Node = Node; // Node class\n  m.Bouton = Node; // alias of node\n\n  m.END = Node.END; // END signal\n\n  m.reserved = [\"id\", \"options\", \"ee\", \"observers\", \"upstreams\", \"downstreams\", \"meta\", \"push\", \"onReceive\", \"onSignal\", \"onError\", \"onEnd\", \"send\", \"observe\", \"to\", \"pull\", \"onRequest\", \"request\", \"from\", \"isErrorSignal\", \"isEndSignal\", \"throwError\", \"invokeObservers\"];\n  function indexNode(node) {\n    var _iterator = _createForOfIteratorHelper(m._indexers.values()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var indexer = _step.value;\n        indexer(node);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  /**\n   * Add an operator\n   * @param  {string} name   - the name of the operator\n   * @param  {function} operator - the operator function\n   * @return {bouton}          the bouton module\n   */\n  function addOperator(name, operator) {\n    if (m.reserved.indexOf(name) >= 0) {\n      console.warn(\"can't add operator '\".concat(name, \"', name is reserved. \"));\n      return m;\n    }\n    function fn() {\n      var node = operator.apply(void 0, arguments);\n      node.meta = {};\n      shadowCopy(this.meta, node.meta);\n      indexNode(node);\n      return this.to(node);\n    }\n    ;\n    Node.prototype[name] = fn;\n    m[name] = function () {\n      var node = operator.apply(void 0, arguments);\n      node.meta = {};\n      shadowCopy(m._meta, node.meta);\n      indexNode(node);\n      return node;\n    };\n    return m;\n  }\n  m.addOperator = addOperator;\n\n  /**\n   * Add multiple operators\n   * @param {object} operators - name:operator pair\n   * @return {bouton} the bouton module\n   */\n  function addOperators(ops) {\n    for (var name in ops) {\n      m.addOperator(name, ops[name]);\n    }\n  }\n  m.addOperators = addOperators;\n\n  /**\n   * add a source\n   * @param {string} name   - the source name\n   * @param {function} source - the source function\n   * @return {bouton}  the bouton module\n   */\n  function addSource(name, source) {\n    if (m.reserved.indexOf(name) >= 0) {\n      console.warn(\"can't add source '\".concat(name, \"', name is reserved. \"));\n      return m;\n    }\n    m[name] = function () {\n      var node = source.apply(void 0, arguments);\n      node.meta = {};\n      shadowCopy(m._meta, node.meta);\n      indexNode(node);\n      return node;\n    };\n    return m;\n  }\n  m.addSource = addSource;\n\n  /**\n   * Add multiple sources\n   * @param {object} srcs - name:source pair\n   * @return {bouton} the bouton module\n   */\n  function addSources(srcs) {\n    for (var name in srcs) {\n      m.addSource(name, srcs[name]);\n    }\n    return m;\n  }\n  m.addSources = addSources;\n\n  /**\n   * add querier\n   * @param {string} name - the querier name\n   * @param {object} querier - the querier object with query method\n   * @return {bouton} the bouton module\n   */\n  function addQuerier(name, querier) {\n    m[name] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return querier.query.apply(querier, [m].concat(args));\n    };\n    return m;\n  }\n  m.addQuerier = addQuerier;\n\n  /**\n   * add indexer\n   * @param {string} name - the indexer name\n   * @param {object} indexer - the indexer object with index method\n   * @return {bouton} the bouton module\n   */\n  function addIndexer(name, indexer) {\n    m._indexers.set(name, function (node) {\n      indexer.index(m, node);\n    });\n    return m;\n  }\n  m.addIndexer = addIndexer;\n\n  /**\n   * load default sources and operators\n   * @return {[type]} [description]\n   */\n  function extendDefault() {\n    var operators = __webpack_require__(/*! ./operators */ \"./lib/operators.js\"); // default operators\n    var sources = __webpack_require__(/*! ./sources */ \"./lib/sources.js\"); // default sources\n\n    m.addSources(sources);\n    m.addOperators(operators);\n    return m;\n  }\n  m[\"default\"] = extendDefault;\n  m.observers = {};\n  m.Node.globalObservers = m.observers;\n  function extend(extension) {\n    if (typeof extension === \"string\") {\n      extension = __webpack_require__(\"./lib sync recursive\")(extension);\n    }\n    if (extension.operators) {\n      m.addOperators(extension.operators);\n    }\n    if (extension.sources) {\n      m.addSources(extension.sources);\n    }\n    if (extension.observers) {\n      for (var name in extension.observers) {\n        m.observers[name] = extension.observers[name];\n      }\n    }\n    if (extension.indexers) {\n      for (var _name in extension.indexers) {\n        m.addIndexer(_name, extension.indexers[_name]);\n      }\n    }\n    if (extension.queriers) {\n      for (var _name2 in extension.queriers) {\n        m.addQuerier(_name2, extension.queriers[_name2]);\n      }\n    }\n    if (extension.others) {\n      for (var _name3 in extension.others) {\n        m[_name3] = extension.others[_name3];\n      }\n    }\n    return m;\n  }\n  m.extend = extend;\n\n  /**\n   * set meta for the bouton object\n   */\n  function setMeta(metadata) {\n    m._meta = metadata;\n  }\n  m.setMeta = setMeta;\n\n  /**\n   * set single meta data for the bouton object\n   */\n  function addMeta(name, meta) {\n    m._meta[name] = meta;\n  }\n  m.addMeta = addMeta;\n\n  /**\n   * remove meta data\n   */\n  function removeMeta(name) {\n    if (m._meta.hasOwnProperty(name)) {\n      delete m._meta[name];\n    }\n  }\n  m.removeMeta = removeMeta;\n  return m;\n}\nvar m = newInstance();\nm[\"new\"] = newInstance;\nmodule.exports = m;\n\n//# sourceURL=webpack://bouton/./lib/index.js?");

/***/ }),

/***/ "./lib/operators.js":
/*!**************************!*\
  !*** ./lib/operators.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nvar Node = __webpack_require__(/*! ./Node */ \"./lib/Node.js\");\nfunction map(fn) {\n  var MapNode = /*#__PURE__*/function (_Node) {\n    _inherits(MapNode, _Node);\n    var _super = _createSuper(MapNode);\n    function MapNode(options, eventemitter) {\n      var _this;\n      _classCallCheck(this, MapNode);\n      _this = _super.call(this, options, eventemitter);\n      _this.fn = options;\n      return _this;\n    }\n    _createClass(MapNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        var out = this.fn(signal);\n        this.send(out);\n      }\n    }]);\n    return MapNode;\n  }(Node);\n  return new MapNode(fn);\n}\nexports.map = map;\nfunction filter(fn) {\n  var FilterNode = /*#__PURE__*/function (_Node2) {\n    _inherits(FilterNode, _Node2);\n    var _super2 = _createSuper(FilterNode);\n    function FilterNode(options, eventemitter) {\n      var _this2;\n      _classCallCheck(this, FilterNode);\n      _this2 = _super2.call(this, options, eventemitter);\n      _this2.fn = options;\n      return _this2;\n    }\n    _createClass(FilterNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        if (fn(signal)) {\n          this.send(signal);\n        } else {\n          // request next signal\n          this.request();\n        }\n      }\n    }]);\n    return FilterNode;\n  }(Node);\n  return new FilterNode(fn);\n}\nexports.filter = filter;\nfunction reduce(memo, iterator) {\n  var ReduceNode = /*#__PURE__*/function (_Node3) {\n    _inherits(ReduceNode, _Node3);\n    var _super3 = _createSuper(ReduceNode);\n    function ReduceNode(options, eventemitter) {\n      var _this3;\n      _classCallCheck(this, ReduceNode);\n      _this3 = _super3.call(this, options, eventemitter);\n      _this3.memo = _this3.options.memo;\n      _this3.iterator = _this3.options.iterator;\n      _this3.END = false;\n      return _this3;\n    }\n    _createClass(ReduceNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        this.memo = this.iterator.call(this, this.memo, signal);\n        this.request(); // back pressure call for next\n      }\n    }, {\n      key: \"onEnd\",\n      value: function onEnd() {\n        this.send(this.memo);\n        this.END = true;\n      }\n    }, {\n      key: \"onRequest\",\n      value: function onRequest(cmd) {\n        if (!this.END) {\n          this.request();\n        } else {\n          this.send(Node.END);\n        }\n      }\n    }]);\n    return ReduceNode;\n  }(Node);\n  return new ReduceNode({\n    memo: memo,\n    iterator: iterator\n  });\n}\nexports.reduce = reduce;\nfunction errors(fn) {\n  var ErrorsNode = /*#__PURE__*/function (_Node4) {\n    _inherits(ErrorsNode, _Node4);\n    var _super4 = _createSuper(ErrorsNode);\n    function ErrorsNode(options, eventemitter) {\n      var _this4;\n      _classCallCheck(this, ErrorsNode);\n      _this4 = _super4.call(this, options, eventemitter);\n      _this4.fn = options;\n      return _this4;\n    }\n    _createClass(ErrorsNode, [{\n      key: \"onError\",\n      value: function onError(error) {\n        var _this5 = this;\n        this.fn(error, function (signal) {\n          _this5.send(signal);\n        });\n      }\n    }]);\n    return ErrorsNode;\n  }(Node);\n  return new ErrorsNode(fn);\n}\n;\nexports.errors = errors;\nfunction sink() {\n  var SinkNode = /*#__PURE__*/function (_Node5) {\n    _inherits(SinkNode, _Node5);\n    var _super5 = _createSuper(SinkNode);\n    function SinkNode() {\n      _classCallCheck(this, SinkNode);\n      return _super5.apply(this, arguments);\n    }\n    _createClass(SinkNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        this.request();\n      }\n    }, {\n      key: \"from\",\n      value: function from(node) {\n        this.request();\n      }\n    }]);\n    return SinkNode;\n  }(Node);\n  return new SinkNode();\n}\n;\nexports.sink = sink;\nfunction throttle(ms) {\n  var last = new Date().getTime();\n  var ThrottleNode = /*#__PURE__*/function (_Node6) {\n    _inherits(ThrottleNode, _Node6);\n    var _super6 = _createSuper(ThrottleNode);\n    function ThrottleNode() {\n      _classCallCheck(this, ThrottleNode);\n      return _super6.apply(this, arguments);\n    }\n    _createClass(ThrottleNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        var now = new Date().getTime();\n        if (now - ms >= last) {\n          last = now;\n          this.send(signal);\n        }\n      }\n    }]);\n    return ThrottleNode;\n  }(Node);\n  return new ThrottleNode(ms);\n}\n;\nexports.throttle = throttle;\nfunction scan(n, add) {\n  var ScanNode = /*#__PURE__*/function (_Node7) {\n    _inherits(ScanNode, _Node7);\n    var _super7 = _createSuper(ScanNode);\n    function ScanNode(options, eventemitter) {\n      var _this6;\n      _classCallCheck(this, ScanNode);\n      _this6 = _super7.call(this, options, eventemitter);\n      _this6.n = options.n;\n      _this6.add = options.add;\n      return _this6;\n    }\n    _createClass(ScanNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        this.n = this.add.call(this, this.n, signal);\n        this.send(this.n);\n      }\n    }]);\n    return ScanNode;\n  }(Node);\n  return new ScanNode({\n    n: n,\n    add: add\n  });\n}\n;\nexports.scan = scan;\nfunction act(fn) {\n  var ActNode = /*#__PURE__*/function (_Node8) {\n    _inherits(ActNode, _Node8);\n    var _super8 = _createSuper(ActNode);\n    function ActNode(options, eventemitter) {\n      var _this7;\n      _classCallCheck(this, ActNode);\n      _this7 = _super8.call(this, options, eventemitter);\n      _this7.fn = options;\n      return _this7;\n    }\n    _createClass(ActNode, [{\n      key: \"onSignal\",\n      value: function onSignal(signal) {\n        this.fn(signal);\n        this.send(signal);\n      }\n    }]);\n    return ActNode;\n  }(Node);\n  return new ActNode(fn);\n}\nexports.act = act;\nfunction done(fn) {\n  var DoneNode = /*#__PURE__*/function (_Node9) {\n    _inherits(DoneNode, _Node9);\n    var _super9 = _createSuper(DoneNode);\n    function DoneNode(options, eventemitter) {\n      var _this8;\n      _classCallCheck(this, DoneNode);\n      _this8 = _super9.call(this, options, eventemitter);\n      _this8.fn = options;\n      return _this8;\n    }\n    _createClass(DoneNode, [{\n      key: \"onEnd\",\n      value: function onEnd(signal) {\n        this.fn(signal);\n      }\n    }]);\n    return DoneNode;\n  }(Node);\n  return new DoneNode(fn);\n}\nexports.done = done;\n\n//# sourceURL=webpack://bouton/./lib/operators.js?");

/***/ }),

/***/ "./lib/sources.js":
/*!************************!*\
  !*** ./lib/sources.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nvar Node = __webpack_require__(/*! ./Node */ \"./lib/Node.js\");\nvar ArraySourceNode = /*#__PURE__*/function (_Node) {\n  _inherits(ArraySourceNode, _Node);\n  var _super = _createSuper(ArraySourceNode);\n  function ArraySourceNode(options, eventemitter) {\n    var _this;\n    _classCallCheck(this, ArraySourceNode);\n    _this = _super.call(this, options, eventemitter);\n    _this.source = _this.options;\n    _this.index = 0;\n    return _this;\n  }\n  _createClass(ArraySourceNode, [{\n    key: \"onRequest\",\n    value: function onRequest(cmd) {\n      if (this.source.length === this.index) {\n        this.send(Node.END);\n        this.index++;\n      } else if (this.source.length > this.index) {\n        this.send(this.source[this.index]);\n        this.index++;\n      }\n    }\n  }]);\n  return ArraySourceNode;\n}(Node);\nfunction asList(array) {\n  return new ArraySourceNode(array);\n}\nexports.asList = asList;\nvar JustOneNode = /*#__PURE__*/function (_Node2) {\n  _inherits(JustOneNode, _Node2);\n  var _super2 = _createSuper(JustOneNode);\n  function JustOneNode(options, eventemitter) {\n    var _this2;\n    _classCallCheck(this, JustOneNode);\n    _this2 = _super2.call(this, options, eventemitter);\n    _this2.value = _this2.options;\n    _this2.visited = 0;\n    return _this2;\n  }\n  _createClass(JustOneNode, [{\n    key: \"onRequest\",\n    value: function onRequest(cmd) {\n      if (this.visited == 0) {\n        this.send(this.value);\n        this.visited++;\n      } else if (this.visited == 1) {\n        this.send(Node.END);\n        this.visited++;\n      }\n    }\n  }]);\n  return JustOneNode;\n}(Node);\nfunction just(value) {\n  return new JustOneNode(value);\n}\nexports.just = just;\n\n//# sourceURL=webpack://bouton/./lib/sources.js?");

/***/ }),

/***/ "./lib/web-entry.js":
/*!**************************!*\
  !*** ./lib/web-entry.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nwindow.bouton = (__webpack_require__(/*! ./index.js */ \"./lib/index.js\")[\"default\"])();\nwindow.bouton.fromDOMEvent = function (element, event) {\n  var DOMEventNode = /*#__PURE__*/function (_bouton$Node) {\n    _inherits(DOMEventNode, _bouton$Node);\n    var _super = _createSuper(DOMEventNode);\n    function DOMEventNode(options, eventemitter) {\n      var _this;\n      _classCallCheck(this, DOMEventNode);\n      _this = _super.call(this, options, eventemitter);\n      _this.event = _this.options.event;\n      _this.element = _this.options.element;\n      return _this;\n    }\n    _createClass(DOMEventNode, [{\n      key: \"to\",\n      value: function to(downstream) {\n        var _this2 = this;\n        this.element.addEventListener(this.event, function () {\n          _this2.send({\n            event: _this2.event,\n            sourceId: _this2.element.getAttribute(\"id\")\n          });\n        });\n        return _get(_getPrototypeOf(DOMEventNode.prototype), \"to\", this).call(this, downstream);\n      }\n    }]);\n    return DOMEventNode;\n  }(bouton.Node);\n  return new DOMEventNode({\n    event: event,\n    element: element\n  });\n};\n\n//# sourceURL=webpack://bouton/./lib/web-entry.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://bouton/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var v1 = __webpack_require__(/*! ./v1 */ \"./node_modules/uuid/v1.js\");\nvar v4 = __webpack_require__(/*! ./v4 */ \"./node_modules/uuid/v4.js\");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n//# sourceURL=webpack://bouton/./node_modules/uuid/index.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack://bouton/./node_modules/uuid/lib/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/***/ ((module) => {

eval("// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n//# sourceURL=webpack://bouton/./node_modules/uuid/lib/rng-browser.js?");

/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n//# sourceURL=webpack://bouton/./node_modules/uuid/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack://bouton/./node_modules/uuid/v4.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/web-entry.js");
/******/ 	
/******/ })()
;